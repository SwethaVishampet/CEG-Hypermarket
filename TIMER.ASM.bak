$MOD186
$ep
NAME TIMER
; Main program for uPD70208 microcomputer system
;
; Author: 	Dr Tay Teng Tiow
; Address:     	Department of Electrical Engineering 
;         	National University of Singapore
;		10, Kent Ridge Crescent
;		Singapore 0511.	
; Date:   	6th September 1991
;
; This file contains proprietory information and cannot be copied 
; or distributed without prior permission from the author.
; =========================================================================

public	serial_rec_action,timer2_action , timer1_action
extrn	print_char:far, print_2hex:far, iodefine:far
extrn   set_timers:far

STACK_SEG	SEGMENT
		DB	256 DUP(?)
	TOS	LABEL	WORD
STACK_SEG	ENDS


DATA_SEG	SEGMENT
	TIMER0_MESS	DB	10,13,'TIMER0 INTERRUPT    '
	TIMER1_MESS	DB	10,13,'TIMER1 INTERRUPT    '
	TIMER2_MESS	DB	10,13,'TIMER2 INTERRUPT    '
	T_COUNT		DB	2FH
	T_COUNT_SET	DB	2FH
	REC_MESS	DB	10,13,'Period of timer0 =     '
  TEST_PRINT_SERIAL DB 2 DUP(0H), 10,13
 
  KEY_DECODE 	DB 32 DUP('0')
	KEYPAD_DECODE 	DB 32 DUP(0)
  LAST_FOUND 	DB 0H ; 0 NO KEY FOUND, 1 KEY FOUND
  KEYPAD_INPUT 	DB 33 
  LED_COUNT 	DB 0H
  LED_CURRENT_DIGIT DB 01H
  LED_MAX_COUNT	 DB 06H
  LED_DISPLAY_Q 	DB 6 DUP(00H)
  LED_DECODE DB 3FH, 06H, 5BH, 4FH, 66H, 6DH, 7DH, 07H, 7FH, 6FH
  ;-------------|0 , 1   , 2  , 3 ,  4 ,  5 ,  6 ,  7 ,  8 ,  9
DATA_SEG	ENDS

; 8255 register addresses
; PCS1
IC8255_PORTA_ADDR EQU 80H;
IC8255_PORTB_ADDR EQU 81H;
IC8255_PORTC_ADDR EQU 82H;
IC8255_CW_ADDR    EQU 83H;

PCS2_ADDR EQU 100H
PCS3_ADDR EQU 180H

DELETE_KEY	EQU 3 
ENTER_KEY 	EQU 1

CODE_SEG	SEGMENT


	PUBLIC		START

ASSUME	CS:CODE_SEG, SS:STACK_SEG, DS:DATA_SEG

START:
	CLI
;initialize stack area
		MOV	AX,STACK_SEG		
		MOV	SS,AX
		MOV	SP,TOS

		MOV AX, DATA_SEG
		MOV DS, AX
	
; Initialize the on-chip pheripherals
		CALL	FAR PTR	IODEFINE
	
	MOV DX, IC8255_CW_ADDR
	MOV AL, 82H  ;PORTC LOWER OUTPUT - PORTB INPUT
	OUT DX, AL
  
	; MOV DX, IC8255_PORTA_ADDR
	; MOV AL, 0FFH
	; OUT DX, AL
	
; Initialize MCS:
	;MPCS
	
	;MMCS

; Initialize key code
	MOV DS:KEYPAD_DECODE[1], 'e'
	MOV DS:KEYPAD_DECODE[2], '0'
	MOV DS:KEYPAD_DECODE[3], 'd';0AH
	MOV DS:KEYPAD_DECODE[4], '9'
	MOV DS:KEYPAD_DECODE[5], '8'
	MOV DS:KEYPAD_DECODE[6], '7'
	MOV DS:KEYPAD_DECODE[7], '6';0AH
	MOV DS:KEYPAD_DECODE[8], '5'
	MOV DS:KEYPAD_DECODE[9], '4'
	MOV DS:KEYPAD_DECODE[10], '3'
	MOV DS:KEYPAD_DECODE[11], '2';0BH
	MOV DS:KEYPAD_DECODE[12], '1'
	MOV DS:KEYPAD_DECODE[13], 'c'
	MOV DS:KEYPAD_DECODE[14], '0'
	MOV DS:KEYPAD_DECODE[15], '*'
	MOV DS:KEYPAD_DECODE[16],  '9'
	MOV DS:KEYPAD_DECODE[17], '8'
	MOV DS:KEYPAD_DECODE[18], '7'
	MOV DS:KEYPAD_DECODE[19], '6';0CH
	MOV DS:KEYPAD_DECODE[20], '5'
	MOV DS:KEYPAD_DECODE[21], 'p'
	MOV DS:KEYPAD_DECODE[22], 'k'
	MOV DS:KEYPAD_DECODE[23], 'x';0CH
	MOV DS:KEYPAD_DECODE[24], 'n'

	MOV DS:KEY_DECODE[1], e
	MOV DS:KEY_DECODE[2], 0
	MOV DS:KEY_DECODE[3], d;0AH
	MOV DS:KEY_DECODE[4], 9
	MOV DS:KEY_DECODE[5], 8
	MOV DS:KEY_DECODE[6], 7
	MOV DS:KEY_DECODE[7], 6;0AH
	MOV DS:KEY_DECODE[8], 5
	MOV DS:KEY_DECODE[9], 4
	MOV DS:KEY_DECODE[10],3
	MOV DS:KEY_DECODE[11],2;0BH
	MOV DS:KEY_DECODE[12], 1
	MOV DS:KEY_DECODE[13], c
	MOV DS:KEY_DECODE[14], 0
	MOV DS:KEY_DECODE[15], *
	MOV DS:KEY_DECODE[16],  9
	MOV DS:KEY_DECODE[17], 8
	MOV DS:KEY_DECODE[18], 7
	MOV DS:KEY_DECODE[19], 6;0CH
	MOV DS:KEY_DECODE[20], 5
	MOV DS:KEY_DECODE[21], p
	MOV DS:KEY_DECODE[22], k
	MOV DS:KEY_DECODE[23], x;0CH
	MOV DS:KEY_DECODE[24], n
	;MOV DS:KEY_DECODE[25], 0
	;MOV DS:KEY_DECODE[26], #
	;MOV DS:KEY_DECODE[27], '*';0DH
	;MOV DS:KEY_DECODE[28], *
	;MOV DS:KEY_DECODE[29], '0'
	;MOV DS:KEY_DECODE[30], #
	;MOV DS:KEY_DECODE[31], 0DH
	

; ^^^^^^^^^^^^^^^^^  Start of User Main Routine  ^^^^^^^^^^^^^^^^^^
	call set_timers
                 STI
NEXT:     


		
; ENTER BARCODE
; CHECK IF KEY INPUT IS 0->9 => STORE TO BARCODE
; IF KEY IS DELETE => DELETE ONE NUMBER
; IF ENTER THEN CHECK WHETHER THE BARCODE IS 6 DIGITS
; UPDATE THE LED ON THE WAY
; IF CANCEL THEN JUMP TO THE START
; AFTER ENTER, CHECK THE BARCODE, IF CORRECT THEN OUTPUT TO LCD ITS INFO. IF NOT THEN ASK TO RE-ENTER

; ENTER QUANTITY
; THE SAME AS BARCODE BUT ONLY 3 DIGITS

; UPDATE TOTAL ITEMS
; UPDATE TOTAL PRICE
; IF AT LEAST 1 ITEM IN RACKET, USER CAN CHECK OUT
; IF CHECK OUT, VOICE OUT TOTAL PRICE, SEND TRANSACTION VIA SERIAL PORT, RESET VARIABLE



; INITIALIAZATION:
	; MOV DS:LED_COUNT, 06H
	; MOV DS:LED_CURRENT_DIGIT, 06H
; ====================================================================================================================================================
ENTER_BARCODE:
	MOV DS:LED_COUNT, 00H
	MOV DS:LED_MAX_COUNT, 06H
ENTER_BARCODE_LOOP:
		CALL FAR PTR FETCH_DIGIT
		
		;CHECK IF BARCODE IS 6 DIGIT
		MOV AL, DS:LED_COUNT
		CMP DS:LED_MAX_COUNT, AL
		JNE END_ONE_BARCODE_LOOP;---NOT FULL
		CMP DS:KEYPAD_INPUT, ENTER_KEY
		JNE NOT_ENTER_BARCODE
		MOV DS:KEYPAD_INPUT, 33
		JMP ENTER_QUANTITY
		NOT_ENTER_BARCODE:
		
	END_ONE_BARCODE_LOOP:
	JMP ENTER_BARCODE_LOOP
	;SEND BARCODE TO PC THROUGH SERIAL PORT^^^^^^^^^^^^^^^^^^^^^^^^^^^^
		;VOICE OUT BARCODE	
;====================================================================================================================================================
ENTER_QUANTITY:
	MOV DS:LED_COUNT, 00H
	MOV DS:LED_MAX_COUNT, 03H
ENTER_QUANTITY_LOOP:
		CALL FAR PTR FETCH_DIGIT
		
		CMP DS:KEYPAD_INPUT, ENTER_KEY
		JNE NOT_ENTER_QUANTITY
		MOV DS:KEYPAD_INPUT, 33
		JMP DO_STUFF
		NOT_ENTER_QUANTITY:
		
	END_ONE_QUANTITY_LOOP:
	JMP ENTER_QUANTITY_LOOP

;SEND QUANTITY TO PORT
;VOICE OUT
;====================================================================================================================================================
DO_STUFF:
COMPUTE_SUBTOTAL:

	
JMP NEXT

; ^^^^^^^^^^^^^^^ End of User main routine ^^^^^^^^^^^^^^^^^^^^^^^^^

FETCH_DIGIT PROC FAR
	PUSH AX
	PUSH BX
	PUSH CX
	PUSH DX
		
		CMP DS:KEYPAD_INPUT, 0
		JE NUMBER
		CMP DS:KEYPAD_INPUT, 1
		JE NUMBER
		CMP DS:KEYPAD_INPUT, 2
		JE NUMBER
		CMP DS:KEYPAD_INPUT, 8
		JE NUMBER
		CMP DS:KEYPAD_INPUT, 9
		JE NUMBER
		CMP DS:KEYPAD_INPUT, 10
		JE NUMBER
		CMP DS:KEYPAD_INPUT, 16
		JE NUMBER
		CMP DS:KEYPAD_INPUT, 17
		JE NUMBER
		CMP DS:KEYPAD_INPUT, 18
		JE NUMBER
		CMP DS:KEYPAD_INPUT, 25
		JE NUMBER
		
		JMP NOT_NUMBER
		
	NUMBER:	
		CALL FAR PTR PUSH_TO_LED_Q
		MOV DS:KEYPAD_INPUT, 33 ;--------CLEAR KEYPAD INPUT
		JMP END_ONE_LOOP
	
	
	NOT_NUMBER:
		CMP DS:KEYPAD_INPUT, DELETE_KEY
		JNE NOT_DELETE
		CALL FAR PTR POP_FROM_LED_Q 
		MOV DS:KEYPAD_INPUT, 33
		NOT_DELETE:
		
	END_ONE_LOOP:

	POP DX
	POP CX
	POP BX
	POP AX
	RET
FETCH_DIGIT ENDP

	
;------------------------------------------------------------------------------	
SERIAL_REC_ACTION	PROC	FAR
		PUSH	CX
		PUSH 	BX
		PUSH	DS

		MOV	BX,DATA_SEG		;initialize data segment register
		MOV	DS,BX

		CMP	AL,'<'
		JNE	S_FAST

		INC	DS:T_COUNT_SET
		INC	DS:T_COUNT_SET

		JMP	S_NEXT0
S_FAST:
		CMP	AL,'>'
		JNE	S_RET

		DEC	DS:T_COUNT_SET
		DEC	DS:T_COUNT_SET

S_NEXT0:
		MOV	CX,22			;initialize counter for message
		MOV	BX,0

S_NEXT1:	MOV	AL,DS:REC_MESS[BX]	;print message
		call	FAR ptr print_char
		INC	BX
		LOOP	S_NEXT1

		MOV	AL,DS:T_COUNT_SET	;print current period of timer0
		CALL	FAR PTR PRINT_2HEX
S_RET:
		POP	DS
		POP	BX
		POP	CX
		RET
SERIAL_REC_ACTION	ENDP

;TIMER0_ACTION	PROC	FAR
;		PUSH	AX
;		PUSH	DS
;		PUSH	BX
;		PUSH	CX



	
;		POP	CX
;		POP	BX
;		POP	DS
;		POP 	AX
;		RET
;TIMER0_ACTION	ENDP















TIMER1_ACTION	PROC	FAR
		PUSH	AX
		PUSH	DS
		PUSH	BX
		PUSH	CX

		MOV	AX,DATA_SEG
		MOV	DS,AX
	
		; DEC	DS:T_COUNT
		; JNZ	T_NEXT1
		; MOV	AL,DS:T_COUNT_SET
		; MOV	DS:T_COUNT,AL

		; MOV	CX,20
		; MOV	BX,0H
; T_NEXT0:
		; MOV	AL,DS:TIMER0_MESS[BX]
		; INC	BX
		; CALL 	FAR PTR PRINT_CHAR
		CALL FAR PTR KEYPAD_ROUTINE
		;CALL FAR PTR LED_ROUTINE
		; LOOP	T_NEXT0

T1_NEXT:	
		POP	CX
		POP	BX
		POP	DS
		POP AX
		RET
TIMER1_ACTION	ENDP

TIMER2_ACTION	PROC	FAR
		PUSH	AX
		PUSH	DS
		PUSH	BX
		PUSH	CX

		MOV	AX,DATA_SEG
		MOV	DS,AX
	
		; DEC	DS:T_COUNT
		; JNZ	T_NEXT1
		; MOV	AL,DS:T_COUNT_SET
		; MOV	DS:T_COUNT,AL

		; MOV	CX,20
		; MOV	BX,0H
; T_NEXT0:
		; MOV	AL,DS:TIMER0_MESS[BX]
		; INC	BX
		; CALL 	FAR PTR PRINT_CHAR
		CALL FAR PTR LED_ROUTINE
		;CALL FAR PTR KEYPAD_ROUTINE
		; LOOP	T_NEXT0

T2_NEXT:	
		POP	CX
		POP	BX
		POP	DS
		POP AX
		RET
TIMER2_ACTION	ENDP



DEBOUNCE	PROC	NEAR
			PUSH	CX
			MOV CX, 02380D ; 2380 dec
BACK:		NOP	  ; 3 clocks
			LOOP BACK; 18 clocks

			POP CX
			RET
DEBOUNCE	ENDP





;-------------------------------------------------------------
KEYPAD_ROUTINE PROC FAR
	PUSH AX
	PUSH BX
	PUSH CX
	PUSH DX
	MOV BL, 01H	;initialize BL for key code

	XOR AX, AX	;clear al flags
	MOV DX,IC8255_PORTC_ADDR  
	OUT DX, AX	;ground all rows
	MOV DX, IC8255_PORTB_ADDR


CHECK_KEY_CLOSED:	

	
	IN AL, DX	
	AND AL, 07H	;Mask data lines D7-D3
	CMP AL, 07H ;any key pressed?
	JE CHECK_KEY_CLOSED
	
	CALL DEBOUNCE ; DEBOUNCE
	MOV AL, 07FH	
	MOV BH, 08H	;row counter
NEXT_ROW:	
	ROL AL, 01H ;
	MOV CH, AL	;save 
	MOV DX, IC8255_PORTC_ADDR
	OUT DX, AL	;grounding one row
	
	;CALL SLIGHT_DELAY ; DELAY
	
	MOV DX, IC8255_PORTB_ADDR
	IN AL, DX	
	AND AL, 07H	;Mask D3-D7
	MOV CL, 03H	;column counter
NEXT_COLUMN1:	

	RCR AL, 01H ;move D0 to CF
	JNC KEY_DETECTED	
	INC BL	 
	DEC CL	 
	JNZ NEXT_COLUMN1	
	
	MOV AL, CH	;Load 
	DEC BH	 
	JNZ NEXT_ROW	
	
	JMP NOT_FOUND_KEY
KEY_DETECTED:	
	CMP DS:LAST_FOUND, 1
	JE END_KEYPAD_ROUTINE
	MOV DS:LAST_FOUND, 1
	MOV DS:KEYPAD_INPUT, BL ;---------STORE INPUT TO THIS VARIABLE
	XOR BH, BH
	MOV AL, DS:KEYPAD_DECODE[BX]	;key code 
	CALL FAR PTR PRINT_CHAR
	JMP END_KEYPAD_ROUTINE
	
NOT_FOUND_KEY:
	MOV DS:LAST_FOUND, 0
	 
	END_KEYPAD_ROUTINE:
	POP DX
	POP CX
	POP BX
	POP AX
	RET
KEYPAD_ROUTINE ENDP
;---------------------------------------------------
LED_ROUTINE PROC FAR
	PUSH AX
	PUSH BX
	PUSH CX
	PUSH DX
	
	CMP DS:LED_COUNT, 0H
	JE NO_DIGIT_TO_DISPLAY
	
;SELECT DIGIT
	MOV CH, 01111111B ; FIRST DIGIT
	
	MOV CL, DS:LED_CURRENT_DIGIT
NEXT_LED:	
	ROL CH, CL
	MOV DX, PCS2_ADDR
	MOV AL, CH
	;MOV AL, 00000000B
	OUT DX, AL
	
	;DISPLAY VALUE
	MOV BL, CL
	XOR BH, BH
	DEC BL
	MOV DL, DS:LED_DISPLAY_Q[BX]
	;MOV AL, DL
	;CALL FAR PTR PRINT_2HEX
	MOV BL, DL
	MOV AL, DS:LED_DECODE[BX]
	;MOV AL, 01101101B
	MOV DX, PCS3_ADDR
	OUT DX, AL

	DEC CL
	JNZ LED_CONTINUTE
	MOV CL, DS:LED_COUNT
LED_CONTINUTE:
	MOV DS:LED_CURRENT_DIGIT, CL
	JMP END_LED_ROUTINE
	
NO_DIGIT_TO_DISPLAY:;---CLEAR ALL LED
	MOV DX, PCS2_ADDR
	MOV AL, 11111111B
	;MOV AL, 00000000B
	OUT DX, AL
	
	MOV DX, PCS3_ADDR
	MOV AL, 00000000B
	;MOV AL, 11111111B
	OUT DX, AL
	


END_LED_ROUTINE:

	POP DX
	POP CX
	POP BX
	POP AX
	RET
LED_ROUTINE ENDP
;-------------------------------------------------------------------------

PUSH_TO_LED_Q PROC FAR
	PUSH AX
	PUSH BX
	PUSH CX
	PUSH DX
	
	MOV AL, DS:LED_COUNT
	CMP DS:LED_MAX_COUNT, AL
	JE LED_Q_FULL
	
	INC DS:LED_COUNT
	MOV AL, DS:LED_DISPLAY_Q[4]
	MOV DS:LED_DISPLAY_Q[5], AL
	MOV AL, DS:LED_DISPLAY_Q[3]
	MOV DS:LED_DISPLAY_Q[4], AL
	MOV AL, DS:LED_DISPLAY_Q[2]
	MOV DS:LED_DISPLAY_Q[3], AL
	MOV AL, DS:LED_DISPLAY_Q[1]
	MOV DS:LED_DISPLAY_Q[2], AL
	MOV AL, DS:LED_DISPLAY_Q[0]
	MOV DS:LED_DISPLAY_Q[1], AL
	
	MOV BL, DS:KEYPAD_INPUT
	XOR BH, BH
	MOV AL, DS:KEY_DECODE[BX]
	MOV DS:LED_DISPLAY_Q[0], AL
	
LED_Q_FULL:

	POP DX
	POP CX
	POP BX
	POP AX
	RET
 PUSH_TO_LED_Q ENDP
 
POP_FROM_LED_Q PROC FAR
	PUSH AX
	PUSH BX
	PUSH CX
	PUSH DX
	
	CMP DS:LED_COUNT, 0H
	JE LED_Q_EMPTY
	
	DEC DS:LED_COUNT
	MOV AL, DS:LED_DISPLAY_Q[1]
	MOV DS:LED_DISPLAY_Q[0], AL
	MOV AL, DS:LED_DISPLAY_Q[2]
	MOV DS:LED_DISPLAY_Q[1], AL
	MOV AL, DS:LED_DISPLAY_Q[3]
	MOV DS:LED_DISPLAY_Q[2], AL
	MOV AL, DS:LED_DISPLAY_Q[4]
	MOV DS:LED_DISPLAY_Q[3], AL
	MOV AL, DS:LED_DISPLAY_Q[5]
	MOV DS:LED_DISPLAY_Q[4], AL
	MOV DS:LED_DISPLAY_Q[5], 0H
	
LED_Q_EMPTY:

	
	POP DX
	POP CX
	POP BX
	POP AX
	RET
POP_FROM_LED_Q ENDP
CODE_SEG	ENDS
END
